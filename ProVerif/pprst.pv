(*Dolev-Yao model Open Channel*)
(*Channel between mobile network A and static network B*)
free c:channel.

free a: bitstring [private].
weaksecret a.
free b: bitstring [private].
weaksecret b.


(* RSA modulus *)
type N.


(* Randomness Generated by A *)
free rA: bitstring [private].

(* functions *)


(* A formal query, specifying the attacker can't ever be leaked the
actual cell location and randomness during the protocol. *)
query attacker(a).
query attacker(b).
query attacker(rA).

(*Auxiliary Functions*)
fun hash(bitstring):bitstring.
fun map(bitstring):bitstring.(*secure function of 2H(x)+1*)
fun append(bitstring,bitstring):bitstring.
fun mod(bitstring,N):bitstring.
fun exp_mod(bitstring,bitstring,N):bitstring.
fun inv_mod(bitstring,N):bitstring.
(*fun check(bitstring,bitstring):bool.*)

(*Events*)
event end_STATIC_B(bitstring).
event end_MOBILE_A(bitstring).


(* The process for mobile network A*)
let mobileA(nB:N) =
    (* Preparation *)
    (*new rA:bitstring;*)   
    (*let lA = map(lA) in*)
    let cA = exp_mod(rA, map(a), nB) in
    out (c,cA);
    in (c, cB:bitstring);
    if cB = hash(mod(rA,nB)) then ( 
        let y = hash(mod(append(rA,a),nB)) in
        out(c,y);
    
        event end_MOBILE_A(cB)).








(* The process for static network B*)
let staticB(nB:N) =
    in(c, cA:bitstring);
    let eB = inv_mod(map(b),nB) in
    let x = exp_mod(cA,eB,nB) in
    let cB = hash(x) in
    out (c, cB);
    in (c, y:bitstring);
    if y = hash(mod(append(x,b),nB)) then (
    event end_STATIC_B(y)).

process
    new nB: N;
    ((!mobileA(nB)) | (!staticB(nB)))